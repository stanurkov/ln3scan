const fs = require("fs");
const path = require('path');

console.log("Arguments are: ", process.argv);

let options = [
];


let scanLevel = 0;

const newStringStart = '!!';

const sep = path.sep;

const outDir = '.' + sep + 'ln3' + sep; 

const outFilename = outDir + 'ln3setup.js';

const translations = {};

const fileMask = /\.js$/u;
const jsonFileMask = /\.json$/u;

const scanDir = (path) => {
    const files = fs.readdirSync(path);
    
    if (files) {
        files.forEach(f => {
            if (!f.startsWith('.') && f !== 'node_modules' && f !== 'ln3') {
                const stats = fs.statSync(path + f);

                if (stats.isDirectory()) {
                    scanDir(path + f + sep);
                } else {
                                        
                    if (fileMask.test(f)) {
                        console.log("scanning file --- ", path + f);

                        const buf = fs.readFileSync(path + f);

                        if (buf) {
                            const text = buf.toString();
                            
                            const ln3TextMask = /ln3\.text.\s*"(.*)",\s*"(.*)"/ug;

                            let match, count = 0;
                            
                            while (match = ln3TextMask.exec(text)) {
                                count++;
                                translations[match[1]] = match[2];
                            }
                            
                            const ln3FormatMask = /"format\.(.*)",\s*"(.*)"/ug;

                            while (match = ln3FormatMask.exec(text)) {
                                count++;
                                translations['format.'+match[1]] = match[2];
                            }

                            if (count === 0) {
                                console.log("no match");    
                            } else {
                                console.log("Total matches: ", count);    
                            }
                            
                        } else {
                            console.log("no buf");
                        }
                    }
                }

            }
        });
    }
}

scanDir('.' + sep);

const sortObject = (object) => {
    var sortedObj = {},
        keys = Object.keys(object);

    keys.sort((key1, key2) => {
        if (key1 === key2) return 0;
        if (key1 < key2) return -1;
        return 1;
    });

    for(var index in keys){
        var key = keys[index];
        if(typeof object[key] === 'object' && !(object[key] instanceof Array)){
            sortedObj[key] = sortObject(object[key]);
        } else {
            sortedObj[key] = object[key];
        }
    }

    return sortedObj;
}

const beautify = require("json-beautify");

const beautyObject = obj => beautify(sortObject(obj), null, 4, 80);

const makeUpJson = obj => new Buffer(beautyObject(obj));

const buffer = makeUpJson(translations);

try {
    fs.mkdirSync(outDir);
} catch (e) {
    if (e.code === "EEXIST") {
        console.log("Output dir already exists - ", outDir);
    }
    // console.log(e);
}

const defaultJson = 'default.json';
fs.writeFileSync(outDir + defaultJson, buffer);

const files = fs.readdirSync(outDir);
const defaultJsonUpper = defaultJson.toUpperCase();


let ln3text = 'import ln3 from "ln3";\n\n'+
    '// IMPORTANT: this file is automatically generated, do not modify it unless you are sure in what you are doing!\n' + 
    '// (normally, language strings are changed by modifying corresponding .JSON files)\n\n' +
    'ln3.setLanguages({\n    default: ' + beautyObject(translations); 

if (files) {

    files.forEach(fileName => {

        console.log("Updating " + fileName, jsonFileMask.test(fileName), fileName.localeCompare('default.json'));

        if (jsonFileMask.test(fileName) && fileName.toUpperCase() !== defaultJsonUpper ) {

            const buffer = fs.readFileSync(outDir + fileName);
            
            let lng = null;
            try {
                if (buffer) {
                    lng = JSON.parse(buffer.toString());
                } 
            } catch(e) {
                // ... simply skip JSON error
            }
            
            if (!lng) lng = {};

            let i, s;

            for (i in translations) {
                s = lng[i];
                
                if (typeof s === 'undefined' || s.startsWith(newStringStart)) {
                    lng[i] = newStringStart + translations[i];
                } 
            }

            
            fs.writeFileSync(outDir + fileName, makeUpJson(lng));

            for (i in lng) {
                s = lng[i];
                if (s.startsWith(newStringStart)) {
                    lng[i] = s.substr(newStringStart.length);
                }
            }

            ln3text += ',\n"' + fileName.substr(0, fileName.length - 5) + '": ' + beautyObject(lng);
        }

    });
}

ln3text += '});';

fs.writeFileSync(outFilename, new Buffer(ln3text));



